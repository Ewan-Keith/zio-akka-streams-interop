package org.ekeith.zio.akka.stream

import akka.stream.{ Graph, Materializer, OverflowStrategy, QueueOfferResult, SinkShape, SourceShape }
import akka.stream.scaladsl.{
  Keep,
  RunnableGraph,
  SinkQueueWithCancel,
  SourceQueueWithComplete,
  Sink => AkkaSink,
  Source => AkkaSource
}
import zio.stream.{ ZSink, ZStream }
import zio.{ Chunk, Promise, Task, UIO, ZIO }

import scala.concurrent.Future

object Converters {

  /**
   * Convert a RunnableGraph, that materialises a Future value, to a ZIO Task returning a materialised value.
   *
   * This converter only supports graphs that materialise a value within a Future. The reason for this is that if no
   * value is materialised (e.g. that return the Akka Streams NotUsed value directly outside of a Future) there is
   * no mechanism to monitor stream completion (successful or not). This could result in streams that throw an
   * exception, but that do not raise this exception to ZIO. This is considered an anti-pattern and so is not
   * supported.
   *
   * @param graph An Akka Streams RunnableGraph.
   *
   * @tparam M The type of the materialized value returned within a Future when the graph completes running.
   *
   * @return A ZIO Task, dependent on an Akka Streams Materializer that runs the provided graph.
   */
  def runnableGraphAsTask[M](graph: RunnableGraph[Future[M]]): ZIO[Materializer, Throwable, M] =
    for {
      mat                <- ZIO.environment[Materializer]
      materialisedFuture <- ZIO.effect(graph.run()(mat))
      materialisedValue  <- ZIO.fromFuture(_ => materialisedFuture)
    } yield materialisedValue

  /**
   * Convert an Akka Streams Source into a ZStream.
   *
   * Akka Stream Sources are able to signal their completion to downstream consumers without the use of
   * materialised values. The wrappers in this package take advantage of this, so any finite Akka Streams Source
   * that completes will signal this completion to the generated ZIO Stream.
   *
   * @param source An Akka Streams Source.
   *
   * @tparam A The type of the values generated by the produced ZStream.
   *
   * @return A ZStream, outputting the values of the provided Akka Stream Source.
   */
  def akkaSourceAsZioStream[A](source: Graph[SourceShape[A], _]): UIO[ZStream[Materializer, Throwable, A]] =
    akkaSourceAsZioStreamMat(source).map(_._1)

  /**
   * Convert an Akka Streams Source into a ZStream, and capture its materialised value.
   *
   * @param source  An Akka Streams Source, with a materialised value.
   *
   * @tparam A The type of the values generated by the produced ZStream.
   * @tparam M The type of the materialized value returned when the Akka Streams Source runs.
   *
   * @return A ZStream, outputting the values of the provided Akka Stream Source, and the materialised value of
   *         this stream.
   */
  def akkaSourceAsZioStreamMat[A, M](
    source: Graph[SourceShape[A], M]
  ): UIO[(ZStream[Materializer, Throwable, A], Task[M])] =
    for {
      p <- Promise.make[Throwable, M]
      zs = ZStream
        .fromEffect(
          for {
            mat            <- ZIO.environment[Materializer]
            (sinkQueue, m) <- extractQueueFromSourceM(source, mat)
            _              <- p.succeed(m)
          } yield sinkQueue
        )
        .flatMap(queueToZStream)
    } yield (zs, p.await)

  /** Throwable indicating that a ZIO sink received a new message after the underlying Akka Streams sink had closed */
  case object AkkaSinkValueAfterShutdown extends Throwable

  /**
   * Convert an Akka Streams Sink into a ZSink.
   *
   * @param sink An Akka Streams Sink.
   *
   * @tparam A The type of the values consumed by the produced ZSink.
   *
   * @return A ZSink, ready to consume values and feed them to the provided Akka Streams Sink.
   */
  def akkaSinkAsZioSink[A](sink: Graph[SinkShape[A], _]): UIO[ZSink[Materializer, Throwable, Nothing, A, Unit]] =
    for {
      zSink <- akkaSinkAsZioSinkMat(sink)
    } yield zSink.map(_ => ())

  /**
   * Convert an Akka Streams Sink into a ZSink, returning a materialised value.
   *
   * @param sink An Akka Streams Sink.
   *
   * @tparam A The type of the values consumed by the produced ZSink.
   * @tparam M The type of the materialized value returned when the Akka Streams Sink runs.
   *
   * @return A ZSink, ready to consume values and feed them to the provided Akka Streams Sink.
   */
  def akkaSinkAsZioSinkMat[A, M](sink: Graph[SinkShape[A], M]): UIO[ZSink[Materializer, Throwable, Nothing, A, M]] =
    UIO(
      new ZSink[Materializer, Throwable, Nothing, A, M] {

        type State = (SourceQueueWithComplete[A], Promise[Throwable, M])

        val initial: ZIO[Materializer, Throwable, State] =
          for {
            p                <- Promise.make[Throwable, M]
            mat              <- ZIO.environment[Materializer]
            (sourceQueue, m) <- extractQueueFromSinkM(sink, mat)
            _                <- p.succeed(m)
          } yield (sourceQueue, p)

        def step(state: State, a: A): ZIO[Materializer, Throwable, State] =
          ZIO
            .fromFuture(_ => state._1.offer(a))
            .flatMap({
              case QueueOfferResult.Enqueued    => ZIO.succeed(state)
              case QueueOfferResult.Dropped     => ZIO.succeed(state)
              case QueueOfferResult.Failure(ex) => ZIO.fail(ex)
              case QueueOfferResult.QueueClosed => ZIO.fail(AkkaSinkValueAfterShutdown)
            })

        def cont(state: State): Boolean = true

        def extract(state: State): ZIO[Materializer, Throwable, (M, Chunk[Nothing])] =
          state._2.await.map((_, Chunk.empty))
      }
    )

  private def extractQueueFromSourceM[A, M](
    source: Graph[SourceShape[A], M],
    mat: Materializer
  ): Task[(SinkQueueWithCancel[A], M)] =
    ZIO.effect(
      AkkaSource
        .fromGraph(source)
        .toMat(AkkaSink.queue[A]())(Keep.both)
        .run()(mat)
        .swap
    )

  private def extractQueueFromSinkM[A, M](
    sink: Graph[SinkShape[A], M],
    mat: Materializer
  ): Task[(SourceQueueWithComplete[A], M)] =
    ZIO.effect({
      AkkaSource
        .queue[A](10, OverflowStrategy.backpressure)
        .toMat(sink)(Keep.both)
        .run()(mat)
    })

  private def queueToZStream[A](queue: SinkQueueWithCancel[A]): ZStream[Any, Throwable, A] =
    ZStream
      .repeatEffect(ZIO.fromFuture(_ => queue.pull()))
      .collectWhile({ case Some(x) => x })

}
