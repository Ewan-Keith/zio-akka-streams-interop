package org.ekeith.zio.akka.stream

import akka.stream.{ Graph, Materializer, SourceShape }
import akka.stream.scaladsl.{ Keep, RunnableGraph, SinkQueueWithCancel, Sink => AkkaSink, Source => AkkaSource }
import zio.stream.ZStream
import zio.{ Task, ZIO }

import scala.concurrent.Future

object Converters {

  /**
   * Convert a RunnableGraph to a ZIO Task.
   *
   * @param graph An Akka Streams RunnableGraph.
   *
   * @tparam M The type of the materialized value returned when the graph completes running.
   * @return A ZIO Task, dependent on an Akka Streams Materializer that runs the provided graph.
   */
  def runnableGraphAsTask[M](graph: RunnableGraph[Future[M]]): ZIO[Materializer, Throwable, M] =
    for {
      mat                <- ZIO.environment[Materializer]
      materialisedFuture <- Task(graph.run()(mat))
      materialisedValue  <- ZIO.fromFuture(implicit ec => materialisedFuture)
    } yield materialisedValue

  /**
   * Convert an Akka Streams Source into a ZStream.
   *
   * @param source An Akka Streams Source.
   *
   * @tparam A The type of the values generated by the produced ZStream.
   * @return A ZStream, outputting the values of the provided Akka Stream Source.
   */
  def akkaSourceAsZioStream[A](source: Graph[SourceShape[A], _]): ZStream[Materializer, Throwable, A] =
    ZStream
      .fromEffect(
        for {
          mat       <- ZIO.environment[Materializer]
          sinkQueue <- extractQueueFromSource(source, mat)
        } yield sinkQueue
      )
      .flatMap(queueToZStream)

  private def extractQueueFromSource[A](
    source: Graph[SourceShape[A], _],
    mat: Materializer
  ): Task[SinkQueueWithCancel[A]] =
    ZIO.effect(
      AkkaSource
        .fromGraph(source)
        .toMat(AkkaSink.queue[A]())(Keep.right)
        .run()(mat)
    )

  private def queueToZStream[A](queue: SinkQueueWithCancel[A]): ZStream[Any, Throwable, A] =
    ZStream
      .repeatEffect(ZIO.fromFuture(implicit ec => queue.pull()))
      .collectWhile({ case Some(x) => x })

}
